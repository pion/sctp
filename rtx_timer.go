package sctp

import (
	//"fmt"
	"math"
	"sync"
	"time"
)

const (
	rtoInitial     float64 = 3.0 * 1000  // msec
	rtoMin         float64 = 1.0 * 1000  // msec
	rtoMax         float64 = 60.0 * 1000 // msec
	rtoAlpha       float64 = 0.125
	rtoBeta        float64 = 0.25
	pathMaxRetrans uint    = 5
)

const (
	t1InitTimer int = iota
	t1CookieTimer
	t3RTX
)

// rtoManager manages Rtx timeout values.
// This is an implementation of RFC 4960 sec 6.3.1.
type rtoManager struct {
	srtt   float64
	rttvar float64
	rto    float64
	mutex  sync.RWMutex
}

// newRTOManager creats a new rtoManager.
func newRTOManager() *rtoManager {
	return &rtoManager{
		rto: rtoInitial,
	}
}

// setNewRTT takes a newly measured RTT then adjust the RTO in msec.
func (m *rtoManager) setNewRTT(rtt float64) {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	if m.srtt == 0 {
		// First measurement
		m.srtt = rtt
		m.rttvar = rtt / 2
	} else {
		// Subsequent rtt measurement
		m.rttvar = (1-rtoBeta)*m.rttvar + rtoBeta*(math.Abs(m.srtt-rtt))
		m.srtt = (1-rtoAlpha)*m.srtt + rtoAlpha*rtt
	}
	m.rto = math.Min(math.Max(m.srtt+4*m.rttvar, rtoMin), rtoMax)
}

// getRTO simply returns the current RTO in msec.
func (m *rtoManager) getRTO() float64 {
	m.mutex.RLock()
	defer m.mutex.RUnlock()

	return m.rto
}

// reset resets the RTO variables to the initial values.
func (m *rtoManager) reset() {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	m.srtt = 0
	m.rttvar = 0
	m.rto = rtoInitial
}

// rtxTimerObserver is the inteface to a timer observer.
// NOTE: Observers MUST NOT call start() or stop() method on rtxTimer
// from within these callbacks.
type rtxTimerObserver interface {
	OnRetransmissionTimeout(timerID int, n uint)
	OnRetransmissionFailure(timerID int)
}

// rtxTimer provides the retnransmission timer conforms with RFC 4960 Sec 6.3.1
type rtxTimer struct {
	id         int
	observer   rtxTimerObserver
	running    bool
	stopping   bool
	cancel     chan struct{}
	stopped    chan struct{}
	maxRetrans uint
	mutex      sync.RWMutex
}

// newRTXTimer creates a new retransmission timer.
func newRTXTimer(id int, observer rtxTimerObserver) *rtxTimer {
	return &rtxTimer{
		id:         id,
		observer:   observer,
		cancel:     make(chan struct{}, 1),
		stopped:    make(chan struct{}),
		maxRetrans: pathMaxRetrans,
	}
}

// start starts the timer.
func (t *rtxTimer) start(rto float64) bool {
	// Note: rto value is intentionally not capped by RTO.Min to allow
	// fast timeout for the tests. Non-test code should pass in the
	// rto generated by rtoManager getRTO() method which caps the
	// value at RTO.Min or at RTO.Max.
	var nRtos uint
	started := make(chan bool)

	go func() {
		t.mutex.Lock()
		defer t.mutex.Unlock()

		if t.running {
			started <- false
			return
		}

		// Empty cancel channel
		select {
		case <-t.cancel:
		default:
		}

		t.running = true
		t.stopping = false
		started <- true
		var failed bool

		for !t.stopping && !failed {
			timeout := calculateNextTimeout(rto, nRtos)
			//fmt.Printf("Next timeout: %f [msec]\n", timeout)
			timer := time.NewTimer(time.Duration(timeout) * time.Millisecond)

			t.mutex.Unlock()
			select {
			case <-timer.C:
				nRtos++
				if nRtos <= pathMaxRetrans {
					t.observer.OnRetransmissionTimeout(t.id, nRtos)
				} else {
					failed = true
					t.observer.OnRetransmissionFailure(t.id)
					timer.Stop()
				}
			case <-t.cancel:
				timer.Stop()
			}
			t.mutex.Lock()
		}

		t.running = false
		t.stopping = false
		select {
		case t.stopped <- struct{}{}:
		default:
		}
	}()

	return <-started
}

// stop stops the timer.
func (t *rtxTimer) stop() {
	t.mutex.Lock()

	if t.running {
		t.stopping = true
		t.cancel <- struct{}{}
		t.mutex.Unlock()

		<-t.stopped
		return
	}

	t.mutex.Unlock()
}

// isRunning tests if the timer is running.
func (t *rtxTimer) isRunning() bool {
	t.mutex.RLock()
	defer t.mutex.RUnlock()

	return t.running
}

func calculateNextTimeout(rto float64, nRtos uint) float64 {
	m := 1 << nRtos
	return math.Min(rto*float64(m), rtoMax)
}
