// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>
// SPDX-License-Identifier: MIT

package sctp

import (
	"math"
	"sync"
	"time"
)

const (
	// Recommended values per RFC 9260 section 16.
	// RTO.Initial in msec.
	rtoInitial float64 = 1.0 * 1000

	// RTO.Min in msec.
	rtoMin float64 = 1.0 * 1000

	// RTO.Max in msec.
	defaultRTOMax float64 = 60.0 * 1000

	// RTO.Alpha.
	rtoAlpha float64 = 0.125

	// RTO.Beta.
	rtoBeta float64 = 0.25

	// Max.Init.Retransmits.
	maxInitRetrans uint = 8

	// Path.Max.Retrans.
	pathMaxRetrans uint = 5

	noMaxRetrans uint = 0

	// Clock granularity G (RFC 9260 sec 6.3.1 G1). Use a fine granularity (<100ms).
	// Unit: msec.
	clockGranularity float64 = 1.0
)

// rtoManager manages Rtx timeout values.
// This is an implementation of RFC 9260 sec 6.3.1.
type rtoManager struct {
	srtt     float64
	rttvar   float64
	rto      float64
	noUpdate bool
	mutex    sync.RWMutex
	rtoMax   float64
}

// newRTOManager creates a new rtoManager.
func newRTOManager(rtoMax float64) *rtoManager {
	mgr := rtoManager{
		rto:    rtoInitial,
		rtoMax: rtoMax,
	}
	if mgr.rtoMax == 0 {
		mgr.rtoMax = defaultRTOMax
	}

	return &mgr
}

// setNewRTT takes a newly measured RTT then adjust the RTO in msec.
func (m *rtoManager) setNewRTT(rtt float64) float64 {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	if m.noUpdate {
		return m.srtt
	}

	if m.srtt == 0 {
		// First measurement
		m.srtt = rtt
		m.rttvar = rtt / 2
	} else {
		// Subsequent rtt measurement
		m.rttvar = (1-rtoBeta)*m.rttvar + rtoBeta*(math.Abs(m.srtt-rtt))

		// RFC 9260 sec 6.3.1 G1
		if m.rttvar == 0 {
			m.rttvar = clockGranularity
		}
		m.srtt = (1-rtoAlpha)*m.srtt + rtoAlpha*rtt
	}
	m.rto = math.Min(math.Max(m.srtt+4*m.rttvar, rtoMin), m.rtoMax)

	return m.srtt
}

// getRTO simply returns the current RTO in msec.
func (m *rtoManager) getRTO() float64 {
	m.mutex.RLock()
	defer m.mutex.RUnlock()

	return m.rto
}

// reset resets the RTO variables to the initial values.
func (m *rtoManager) reset() {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	if m.noUpdate {
		return
	}

	m.srtt = 0
	m.rttvar = 0
	m.rto = rtoInitial
}

// set RTO value for testing.
func (m *rtoManager) setRTO(rto float64, noUpdate bool) {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	m.rto = rto
	m.noUpdate = noUpdate
}

// rtxTimerObserver is the interface to a timer observer.
// NOTE: Observers MUST NOT call start() or stop() method on rtxTimer
// from within these callbacks.
type rtxTimerObserver interface {
	onRetransmissionTimeout(timerID int, n uint)
	onRetransmissionFailure(timerID int)
}

type rtxTimerState uint8

const (
	rtxTimerStopped rtxTimerState = iota
	rtxTimerStarted
	rtxTimerClosed
)

// rtxTimer provides the retransmission timer conforms with RFC 9260 Sec 6.3.
type rtxTimer struct {
	timer      *time.Timer
	observer   rtxTimerObserver
	id         int
	maxRetrans uint
	rtoMax     float64
	mutex      sync.Mutex
	rto        float64
	nRtos      uint
	state      rtxTimerState
	pending    uint8
}

// newRTXTimer creates a new retransmission timer.
// if maxRetrans is set to 0, it will keep retransmitting until stop() is called.
// (it will never make onRetransmissionFailure() callback.
func newRTXTimer(id int, observer rtxTimerObserver, maxRetrans uint,
	rtoMax float64,
) *rtxTimer {
	timer := rtxTimer{
		id:         id,
		observer:   observer,
		maxRetrans: maxRetrans,
		rtoMax:     rtoMax,
	}
	if timer.rtoMax == 0 {
		timer.rtoMax = defaultRTOMax
	}
	timer.timer = time.AfterFunc(math.MaxInt64, timer.timeout)
	timer.timer.Stop()

	return &timer
}

func (t *rtxTimer) calculateNextTimeout() time.Duration {
	timeout := calculateNextTimeout(t.rto, t.nRtos, t.rtoMax)

	return time.Duration(timeout) * time.Millisecond
}

func (t *rtxTimer) timeout() {
	t.mutex.Lock()
	if t.pending--; t.pending == 0 && t.state == rtxTimerStarted {
		if t.nRtos++; t.maxRetrans == 0 || t.nRtos <= t.maxRetrans {
			t.timer.Reset(t.calculateNextTimeout())
			t.pending++
			defer t.observer.onRetransmissionTimeout(t.id, t.nRtos)
		} else {
			t.state = rtxTimerStopped
			defer t.observer.onRetransmissionFailure(t.id)
		}
	}
	t.mutex.Unlock()
}

// start starts the timer.
func (t *rtxTimer) start(rto float64) bool {
	t.mutex.Lock()
	defer t.mutex.Unlock()

	// this timer is already closed or aleady running
	if t.state != rtxTimerStopped {
		return false
	}

	// Note: rto value is intentionally not capped by RTO.Min to allow
	// fast timeout for the tests. Non-test code should pass in the
	// rto generated by rtoManager getRTO() method which caps the
	// value at RTO.Min or at RTO.Max.

	// RFC 9260 sec 6.3.2 R1: the RTO used here SHOULD include any doubling
	// due to previous expirations; we therefore preserve t.nRtos and only
	// update the base RTO.
	t.rto = rto
	t.state = rtxTimerStarted
	t.pending++
	t.timer.Reset(t.calculateNextTimeout())

	return true
}

// restart restarts the running timer using the current backoff state (R3).
// It does not modify nRtos; returns false if the timer isn't running.
func (t *rtxTimer) restart() bool {
	t.mutex.Lock()
	defer t.mutex.Unlock()

	if t.state != rtxTimerStarted {
		return false
	}

	if t.timer.Stop() {
		t.pending--
	}

	t.pending++
	t.timer.Reset(t.calculateNextTimeout())

	return true
}

// stop stops the timer.
func (t *rtxTimer) stop() {
	t.mutex.Lock()
	defer t.mutex.Unlock()

	if t.state == rtxTimerStarted {
		if t.timer.Stop() {
			t.pending--
		}
		t.state = rtxTimerStopped
	}
}

// closes the timer. this is similar to stop() but subsequent start() call
// will fail (the timer is no longer usable).
func (t *rtxTimer) close() {
	t.mutex.Lock()
	defer t.mutex.Unlock()

	if t.state == rtxTimerStarted && t.timer.Stop() {
		t.pending--
	}

	t.state = rtxTimerClosed
}

// updateBaseRTO updates the base RTO (SRTT+4*RTTVAR) and collapses backoff.
// Call this after a NEW RTT measurement is incorporated (RFC 9260 sec 6.3.3 E3).
func (t *rtxTimer) updateBaseRTO(rto float64) {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	t.rto = rto
	t.nRtos = 0
	if t.state == rtxTimerStarted {
		if t.timer.Stop() {
			t.pending--
		}
		t.pending++
		t.timer.Reset(t.calculateNextTimeout())
	}
}

// isRunning tests if the timer is running.
// Debug purpose only.
func (t *rtxTimer) isRunning() bool {
	t.mutex.Lock()
	defer t.mutex.Unlock()

	return t.state == rtxTimerStarted
}

func calculateNextTimeout(rto float64, nRtos uint, rtoMax float64) float64 {
	// RFC 9260 sec 6.3.3 E2: On T3-rtx expiration, RTO <- 2*RTO; optionally
	// bound by RTO.Max (per section 6.3.1 C7).
	if nRtos < 31 {
		m := 1 << nRtos

		return math.Min(rto*float64(m), rtoMax)
	}

	return rtoMax
}
